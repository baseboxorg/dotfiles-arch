#!/usr/bin/env bash

# Helper function to enforce argc and display provided usage string when violated.
# USAGE: "_require $# 3 "$0 [ARGS]" || return 1" means the function needs exactly 3 arguments.
_require () {
    if [[ "$1" -ne "$2" ]]; then
        printf "%s\n" "USAGE: ${3}" ; return 1
    fi
}


# Shows the source code of a shell function.
src () {
    _require $# 1 "$0 [shell function name]" || return 1
    declare -f "$1" || printf "%s\n" "${1} is not a shell function."
}


# mkdir and cd in one command.
alias mc='mkcd'
mkcd () {
    _require $# 1 "$0 [path/to/newdir]" || return 1
    if [[ -d "$1" ]]; then
        printf "%s\n" "${1} already exists."
    else
        mkdir -p "$1" && builtin cd "$1"
    fi
}


# auto-ls after cd. Does not show hidden files.
cd () {
    if [[ -n "$1" ]]; then
        builtin cd "$1" && ls -lph
    else
        builtin cd "$HOME" && ls -lph
    fi
}


# quick name-based find shortcut.
f () {
    _require $# 1 "$0 [file or dir name]" || return 1
    find . -iname "*$1*"
}


# permission cleanup for the current directory.
pclean () {
    sudo find . -type d -exec chmod 775 {} \;
    sudo find . -type f -executable -exec chmod 775 {} \;
    sudo find . -type f -not -executable -exec chmod 664 {} \;
}


# enforce permissions and ownership on important files.
lockdown () {
    sudo chown -R "$(whoami)" "${HOME}/."{ssh,gnupg}
    sudo chmod 700 "${HOME}/."{ssh,gnupg}
    sudo chmod 600 -R "${HOME}/.gnupg/"*
    sudo chmod 700 "${HOME}/.gnupg/private-keys-v1.d"
    sudo chmod 600 -R "${HOME}/.ssh/"*
    sudo chmod 400 -R "${HOME}/.ssh/"*.pem
    sudo chmod 400 "${HOME}/.ssh/id_rsa"*
}


# archive extraction based on file extension.
alias e='extract'
extract () {
    _require $# 1 "$0 [path/to/archive]" || return 1
    if [ -f "$1" ]; then
        case $1 in
            *.tar.gz)    tar xvzf "$1"    ;;
            *.tgz)       tar xvzf "$1"    ;;
            *.tar.bz2)   tar xvjf "$1"    ;;
            *.tbz2)      tar xvjf "$1"    ;;
            *.tar)       tar xvf "$1"     ;;
            *.bz2)       bunzip2 "$1"     ;;
            *.gz)        gunzip "$1"      ;;
            *.zip)       unzip "$1"       ;;
            *.rar)       rar x "$1"       ;;
            *.7z)        7z x "$1"        ;;
            *)           printf "%s\n" "Can't recognize file extension on '${1}'" ;;
        esac
    else
        printf "%s\n" "'${1}' is not a valid file!"
    fi
}


# quick targz shortcut for one directory.
# creates the archive in the target dir's location, with dashes subbed for spaces.
# deletes source files if successful.
archive () {
    _require $# 1 "$0 [path/to/dir]" || return 1
    ARCHIVE="$(printf "%s" "$(dirname "$1")/$(basename "$1").tgz" | tr ' ' '-')"
    tar cvfz "$ARCHIVE" "$1" --remove-files
}


# kills the specified tty.
killtty () {
    _require $# 1 "$0 [tty number]" || return 1
    sudo kill "$(who -u | grep "tty${1}" | tr -s ' ' | cut -d ' ' -f 6)"
}


# unlocks LUKS-encrypted drives and mounts at /tmp/ALIAS.
unlock () {
    _require $# 2 "$0 [path/to/device] [mapper alias]" || return 1
    if ! command -v cryptsetup > /dev/null 2>&1; then
        printf "cryptsetup is not installed.\n" ; return 1
    fi
    MOUNTPOINT="/tmp/${2}"
    if ! mkdir "$MOUNTPOINT"; then
        printf "Choose a different /dev/mapper/ alias.\n" ; return 1
    fi
    sudo cryptsetup luksOpen "$1" "$2" && \
    sudo mount -v "/dev/mapper/${2}" "$MOUNTPOINT"
}


# unmounts from /tmp/ALIAS and locks LUKS-encrypted drives.
lock () {
    _require $# 1 "$0 [MAPPER ALIAS]" || return 1
    if ! command -v cryptsetup > /dev/null 2>&1; then
        printf "cryptsetup is not installed.\n" ; return 1
    fi
    cd "$HOME"                      && \
    sudo umount -v "/tmp/${1}"      && \
    sudo cryptsetup luksClose "$1"  && \
    sudo rmdir "/tmp/${1}"
}


# rsync flag wrapper for backup and sync.
rmirror () {
    _require $# 2 "$0 [/path/to/source/dir] [/path/to/dest/dir]" || return 1
    if ! command -v rsync > /dev/null 2>&1; then
        printf "rsync is not installed.\n" ; return 1
    fi
    rsync -aAXhP --delete "$1" "$2"  # reflect deleted file changes in the destination
}


# special rsync shortcut for home backups.
hmirror () {
    _require $# 1 "$0 [/path/to/backup/dir]" || return 1
    if ! command -v rsync > /dev/null 2>&1; then
        printf "rsync is not installed.\n" ; return 1
    fi
    rsync -aAXhP --delete   \
        --exclude '.cache'  \
        --exclude '.gnupg'  \
        --exclude '.ssh'    \
        "$HOME" "$1"
}


# special rsync shortcut for system backups.
smirror () {
    _require $# 1 "$0 [/path/to/backup/dir]" || return 1
    if ! command -v rsync > /dev/null 2>&1; then
        printf "rsync is not installed.\n" ; return 1
    fi
    sudo rsync -aAXhP --delete \
        --exclude={"/dev/*","/proc/*","/sys/*","/tmp/*","/run/*","/mnt/*","/media/*","/home/*","/lost+found"} \
        "/" "$1"
}


# upload stdin or a file to pb.
pb () {
    if ! command -v curl > /dev/null 2>&1; then
        printf "curl is not installed.\n" ; return 1
    fi
    curl -F "c=@${1:--}" -F p=1 "https://ptpb.pw/"
}


# record and upload asciinema.
rec () {
    if ! command -v asciinema > /dev/null 2>&1; then
        printf "asciinema is not installed.\n" ; return 1
    fi
    asciinema rec "/tmp/$$.json"  && \
    pb "/tmp/$$.json"             && \
    printf "Prepend t/ to view the asciinema!\n"
}


# generate random password.
pwgen () {
    _require $# 1 "$0 [length]" || return 1
    base64 /dev/urandom | head -c "$1" ; printf '\n'
}
